    toRemove.forEach(m=>cluster.removeLayer(m));
    commit();
  };

  /***** POLYGONS CORE + HISTORY *****/
  const polyFG=new L.FeatureGroup(); map.addLayer(polyFG);
  const polyIndex=new Map();
  const historyById=new Map(); // id -> {stack:[],index}

  // Метрики формат
  function formatArea(m2){ return m2>1e6 ? (m2/1e6).toFixed(2)+' км²' : Math.round(m2)+' м²'; }
  function formatLen(m){ return m>1000 ? (m/1000).toFixed(2)+' км' : Math.round(m)+' м'; }

  // Лейблы рёбер при редактировании
  const edgeLabels=new Map(); // id -> L.marker[]
  function clearEdgeLabels(id){
    const arr=edgeLabels.get(id)||[];
    arr.forEach(lbl=>{ try{map.removeLayer(lbl);}catch(_){}}); edgeLabels.delete(id);
  }
  function updateEdgeLabels(id){
    clearEdgeLabels(id);
    if(!(polyEditing && polyEditingTargetId===id)) return;
    const layer=polyIndex.get(id); if(!layer||!layer.getLatLngs) return;
    const rings=layer.getLatLngs()[0]||[];
    if(rings.length<2) return;
    const labels=[];
    for(let i=0;i<rings.length;i++){
      const a=rings[i], b=rings[(i+1)%rings.length];
      const mid=L.latLng((a.lat+b.lat)/2, (a.lng+b.lng)/2);
      const dist=map.distance(a,b);
      const lbl=L.marker(mid,{interactive:false,icon:L.divIcon({className:"",html:`<div style="background:rgba(10,14,22,.85);color:#fff;padding:2px 6px;border-radius:6px;font-size:12px">${formatLen(dist)}</div>`})});
      lbl.addTo(map); labels.push(lbl);
    }
    edgeLabels.set(id,labels);
  }

  function getHistoryPoly(id){ if(!historyById.has(id)) historyById.set(id,{stack:[],index:-1}); return historyById.get(id); }
  function pushHistoryPoly(p){
    const h=getHistoryPoly(p.id);
    const snap=JSON.parse(JSON.stringify(p.geojson));
    if(h.index<h.stack.length-1) h.stack.splice(h.index+1);
    h.stack.push(snap); h.index=h.stack.length-1;
  }
  function applyHistoryPoly(p,dir){
    const h=getHistoryPoly(p.id), next=h.index+dir;
    if(next<0||next>=h.stack.length) return false;
    h.index=next; const snap=h.stack[h.index];
    p.geojson=JSON.parse(JSON.stringify(snap));
    const old=polyIndex.get(p.id); if(old) polyFG.removeLayer(old);
    const l=layerFromGeo(p.geojson,p.color); polyFG.addLayer(l); polyIndex.set(p.id,l);
    if(p.visible===false) map.removeLayer(l);
    updateEdgeLabels(p.id);
    return true;
  }
  function layerFromGeo(geo,c){ let l=null; L.geoJSON(geo,{style:{color:c||'#ff4d4f',weight:2,fillOpacity:.12}}).eachLayer(x=>l=x); return l; }
  function rebuildPolys(){
    polyIndex.clear(); polyFG.clearLayers();
    for(const p of db.polygons){
      if(!p.geojson) continue;
      const l=layerFromGeo(p.geojson,p.color); if(!l) continue;
      polyFG.addLayer(l); polyIndex.set(p.id,l);
      if(p.visible===false) map.removeLayer(l);
    }
    updatePolygonVisibility();
  }

  /***** POLYGON UI *****/
  const $polyList=document.getElementById('polyList');
  const $polyName=document.getElementById('polyName');
  const $polyColor=document.getElementById('polyColor');
  const $polySearch=document.getElementById('polySearch');

  document.getElementById('btnPolyNew').onclick=()=>{
    new L.Draw.Polygon(map,{shapeOptions:{color:$polyColor.value||'#ff4d4f',weight:2,fillOpacity:.12}}).enable();
  };

  let polyEditToolbar=null, polyEditing=false, polyEditingTargetId=null;

  document.getElementById('btnPolyEdit').onclick=()=>{
    if(polyEditing) return;
    polyEditingTargetId=null; localStorage.removeItem('polyEditingId');
    polyEditToolbar=new L.EditToolbar.Edit(map,{featureGroup:polyFG});
    polyEditToolbar.enable(); polyEditing=true;
  };
  document.getElementById('btnPolyStop').onclick=stopPolyEditing;
  function stopPolyEditing(){
    if(polyEditing&&polyEditToolbar){ polyEditToolbar.disable(); polyEditing=false; map.fire(L.Draw.Event.EDITSTOP); }
    if(polyEditingTargetId) clearEdgeLabels(polyEditingTargetId);
    polyEditingTargetId=null; localStorage.removeItem('polyEditingId');
  }
  document.getElementById('btnPolyUndo').onclick=()=>{
    if(!polyEditingTargetId) return;
    const p=db.polygons.find(x=>x.id===polyEditingTargetId); if(!p) return;
    if(applyHistoryPoly(p,-1)){ save(db).then(()=>{ renderPolyList(); updatePolygonVisibility(); }); }
  };
  document.getElementById('btnPolyRedo').onclick=()=>{
    if(!polyEditingTargetId) return;
    const p=db.polygons.find(x=>x.id===polyEditingTargetId); if(!p) return;
    if(applyHistoryPoly(p,+1)){ save(db).then(()=>{ renderPolyList(); updatePolygonVisibility(); }); }
  };

  map.on(L.Draw.Event.CREATED,async e=>{
    if(e.layerType==="polygon" && (e.layer instanceof L.Polygon)){
      const layer=e.layer; layer.setStyle({color:$polyColor.value||'#ff4d4f',weight:2,fillOpacity:.12});
      polyFG.addLayer(layer);
      const rec={id:uid(),name:($polyName?.value||`Полигон ${db.polygons.length+1}`).trim(),color:$polyColor?.value||'#ff4d4f',visible:true,geojson:layer.toGeoJSON()};
      db.polygons.push(rec); polyIndex.set(rec.id,layer); pushHistoryPoly(rec); await commit();
    } else {
      if(e.layer) e.layer.addTo(map);
    }
  });

  map.on(L.Draw.Event.EDITSTOP,async ()=>{
    for(const p of db.polygons){
      const l=polyIndex.get(p.id); if(l) p.geojson=l.toGeoJSON();
    }
    if(polyEditingTargetId) clearEdgeLabels(polyEditingTargetId);
    await commit();
  });

  map.on('draw:editvertex', ()=>{
    if(!polyEditingTargetId) return;
    const p=db.polygons.find(x=>x.id===polyEditingTargetId); if(!p) return;
    const l=polyIndex.get(p.id); if(!l) return;
    p.geojson=l.toGeoJSON(); pushHistoryPoly(p);
    updateEdgeLabels(p.id);
  });

  function setEditingTarget(id){
    polyEditingTargetId=id||null;
    if(id) localStorage.setItem('polyEditingId',id); else localStorage.removeItem('polyEditingId');
    renderPolyList(); updatePolygonVisibility();
    if(id) updateEdgeLabels(id);
  }

  function polygonStats(p){
    try{
      const layer=polyIndex.get(p.id); const rings=layer?layer.getLatLngs()[0]:null;
      if(!rings||!rings.length) return {S:"—",P:"—"};
      const area=L.GeometryUtil.geodesicArea(rings);
      const per =L.GeometryUtil.length(rings);
      return {S:formatArea(area),P:formatLen(per)};
    }catch(_){ return {S:"—",P:"—"} }
  }

  function renderPolyList(){
    if(!$polyList) return;
    const q=($polySearch?.value||"").trim().toLowerCase();
    const prevScroll=$polyList.scrollTop; $polyList.innerHTML='';

    db.polygons.filter(p=>!q || (p.name||'').toLowerCase().includes(q)).forEach(p=>{
      const wrapper=document.createElement('div'); wrapper.className='item'+(p.id===polyEditingTargetId?' active':'');
      if(collapsedPolygons.has(p.id)) wrapper.classList.add('collapsed');

      const head=document.createElement('div'); head.className='collapse-head';
      const caret=document.createElement('div'); caret.className='caret';
      const title=document.createElement('div'); title.className='name'; title.textContent=p.name||'Полигон';
      const meta=document.createElement('div'); meta.className='meta'; meta.textContent=`id: ${p.id}`;
      head.append(caret,title,meta);
      head.onclick=()=>{
        if(collapsedPolygons.has(p.id)) collapsedPolygons.delete(p.id); else collapsedPolygons.add(p.id);
        setCollapsedSet('collapsedPolygons_v2',collapsedPolygons);
        wrapper.classList.toggle('collapsed');
      };
      wrapper.appendChild(head);

      const body=document.createElement('div'); body.className='section-body';
      const row1=document.createElement('div'); row1.className='item-row';
      const nameInput=document.createElement('input'); nameInput.value=p.name||'Полигон';
      nameInput.onchange=async()=>{p.name=nameInput.value.trim()||p.name; await commit();};
      const color=document.createElement('input'); color.type='color'; color.value=p.color||'#ff4d4f';
      color.onchange=async()=>{p.color=color.value;const l=polyIndex.get(p.id);if(l&&l.setStyle) l.setStyle({color:p.color});await save(db);};
      row1.append(nameInput,color);

      // Метрики только в списке
      const statsRow=document.createElement('div'); statsRow.className='meta';
      const S=document.createElement('span'); const P=document.createElement('span');
      function refreshStats(){ const st=polygonStats(p); S.textContent=`S=${st.S}`; P.textContent=`  P=${st.P}`; }
      refreshStats();
      statsRow.append(S,P);

      const row2=document.createElement('div'); row2.className='tools';
      const toggle=document.createElement('button'); toggle.textContent=p.visible!==false?'Скрыть':'Показать';
      toggle.onclick=async()=>{p.visible=!(p.visible!==false); const l=polyIndex.get(p.id); if(l){ if(p.visible) l.addTo(map); else map.removeLayer(l);} await commit(); };
      const focus=document.createElement('button'); focus.textContent='Фокус';
      focus.onclick=()=>{const l=polyIndex.get(p.id);if(l){ l.addTo(map); map.fitBounds(l.getBounds()); }};
      const editBtn=document.createElement('button'); editBtn.textContent='Редактировать';
      editBtn.onclick=()=>{
        const l=polyIndex.get(p.id);
        if(l){
          l.addTo(map);
          if(polyEditing&&polyEditToolbar){ polyEditToolbar.disable(); }
          polyEditToolbar=new L.EditToolbar.Edit(map,{featureGroup:polyFG});
          polyEditToolbar.enable(); polyEditing=true;
          polyFG.eachLayer(x=>{
            if(x===l){ if(x.editing && !x.editing._enabled) x.editing.enable(); }
            else{ if(x.editing && x.editing._enabled) x.editing.disable(); }
          });
          setEditingTarget(p.id); map.fitBounds(l.getBounds());
          const h=getHistoryPoly(p.id); if(h.stack.length===0){ pushHistoryPoly(p); }
          updateEdgeLabels(p.id);
        }
      };
      const del=document.createElement('button'); del.textContent='❌'; del.className='danger';
      del.onclick=async()=>{if(!confirm('Удалить полигон?')) return; const l=polyIndex.get(p.id); if(l) polyFG.removeLayer(l); polyIndex.delete(p.id); db.polygons=db.polygons.filter(x=>x.id!==p.id); await lfGeo.removeItem(p.id); clearEdgeLabels(p.id); await commit(); if(polyEditingTargetId===p.id){ setEditingTarget(null);} };

      body.append(row1,statsRow);
      row2.append(toggle,focus,editBtn,del);
      body.append(row2);
      wrapper.appendChild(body);

      $polyList.appendChild(wrapper);

      // Обновление метрик при видимых изменениях
      const l=polyIndex.get(p.id);
      if(l){
        l.on('edit', refreshStats);
      }
    });

    $polyList.scrollTop=prevScroll;
  }
  $polySearch.oninput=renderPolyList;
  /***** SELECTED STATE + VISIBILITY *****/
  let selected={};
  function saveSelected(){
    const out={};
    for(const [k,v] of Object.entries(selected)){ out[k]=v instanceof Set?Array.from(v):v; }
    localStorage.setItem('selected_v2',JSON.stringify(out));
  }
  function loadSelected(){
    try{
      const raw=localStorage.getItem('selected_v2'); if(!raw) return;
      const obj=JSON.parse(raw)||{}; selected={};
      for(const [k,v] of Object.entries(obj)){
        const cat=(db?.categories||[]).find(c=>c.id===k);
        if(cat&&cat.type==='checkbox') selected[k]=new Set(Array.isArray(v)?v:[]);
        else selected[k]=v||null;
      }
    }catch(_){selected={};}
  }
  function getSelectedIds(catId){
    const cat=db.categories.find(x=>x.id===catId); const v=selected[catId];
    if(!v) return []; return(cat&&cat.type==='checkbox')?Array.from(v):(v?[v]:[]);
  }
  function getSelectedItemNames(){
    const names=new Set();
    for(const cat of db.categories){
      const ids=getSelectedIds(cat.id);
      if(!ids.length) continue;
      (cat.items||[]).forEach(it=>{if(ids.includes(it.id)) names.add(it.name);});
    }
    return names;
  }
  function updatePolygonVisibility(){
    const names=getSelectedItemNames();
    for(const p of db.polygons){
      const layer=polyIndex.get(p.id); if(!layer) continue;
      const filtered=(p.visible!==false) && (names.size ? names.has(p.name) : false);
      const forceVisible=(polyEditingTargetId && p.id===polyEditingTargetId);
      if(filtered||forceVisible) layer.addTo(map); else map.removeLayer(layer);
    }
  }

  /***** БИБЛИОТЕКА ИКОН OK *****/
  const builtinIcons=[
    {name:"Дом",svg:"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='#fff' d='M3 10L12 3l9 7v10H4z'/></svg>"},
    {name:"Метро",svg:"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><circle cx='12' cy='12' r='9' fill='#e11d48'/><path d='M7 16l5-9 5 9' stroke='#fff' stroke-width='2' fill='none'/></svg>"},
    {name:"Офис",svg:"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><rect x='6' y='3' width='12' height='18' rx='2' fill='#60a5fa'/><path d='M9 7h2M9 11h2M9 15h2M13 7h2M13 11h2M13 15h2' stroke='#0b1020' stroke-width='1.5'/></svg>"},
    {name:"Школа",svg:"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path d='M12 3l9 5-9 5-9-5 9-5z' fill='#fbbf24'/><path d='M5 12v5l7 4 7-4v-5' stroke='#fbbf24' fill='none'/></svg>"},
    {name:"Парковка",svg:"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><rect x='4' y='4' width='16' height='16' rx='3' fill='#22d3ee'/><path d='M9 16V8h5a3 3 0 010 6H9z' fill='#0b1020'/></svg>"}
  ];
  const $iconsOverlay=document.getElementById('iconsOverlay');
  const $iconsClose=document.getElementById('iconsClose');
  const $iconsGrid=document.getElementById('iconsGrid');
  function openIconsLib(onPick){
    $iconsGrid.innerHTML="";
    builtinIcons.forEach(icon=>{
      const cell=document.createElement('div'); cell.className='modal-item';
      const data="data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(icon.svg)));
      const prev=document.createElement('span'); prev.className='preview-icon'; prev.innerHTML=`<img src="${data}">`;
      const name=document.createElement('div'); name.textContent=icon.name;
      cell.append(prev,name); cell.style.cursor='pointer';
      cell.onclick=()=>{ onPick(data); closeIconsLib(); };
      $iconsGrid.appendChild(cell);
    });
    $iconsOverlay.style.display='flex'; document.body.style.overflow='hidden';
  }
  function closeIconsLib(){ $iconsOverlay.style.display='none'; document.body.style.overflow=''; }
  $iconsClose.onclick=closeIconsLib;

  /***** Статистика (Инфо) *****/
  const $infoOverlay=document.getElementById('infoOverlay');
  const $infoClose=document.getElementById('infoClose');
  const $infoBox=document.getElementById('infoBox');
  document.getElementById('btnInfo').onclick=()=>{
    const cats=db.categories.length;
    let items=0, itemsWithCoords=0;
    db.categories.forEach(c=>{items+=(c.items||[]).length;(c.items||[]).forEach(it=>{ if(it.lat!=null&&it.lng!=null) itemsWithCoords++; });});
    const polys=(db.polygons||[]).length;
    $infoBox.innerHTML=`
      <div class="list">
        <div class="item"><div class="item-row"><div class="left"><div class="name">Категорий</div><div class="meta">всего</div></div><div>${cats}</div></div></div>
        <div class="item"><div class="item-row"><div class="left"><div class="name">Элементов</div><div class="meta">всего</div></div><div>${items}</div></div></div>
        <div class="item"><div class="item-row"><div class="left"><div class="name">С координатами</div><div class="meta">элементы</div></div><div>${itemsWithCoords}</div></div></div>
        <div class="item"><div class="item-row"><div class="left"><div class="name">Полигонов</div><div class="meta">всего</div></div><div>${polys}</div></div></div>
      </div>`;
    $infoOverlay.style.display='flex'; document.body.style.overflow='hidden';
  };
  $infoClose.onclick=()=>{$infoOverlay.style.display='none'; document.body.style.overflow='';};

  /***** Импорт конфликтный диалог *****/
  let importDialogCtx=null;
  function showImportDialog(message,ctx){
    importDialogCtx=ctx;
    document.getElementById('importMessage').innerHTML=message;
    document.getElementById('importDialog').style.display='flex'; document.body.style.overflow='hidden';
  }
  function closeImportDialog(){ importDialogCtx=null; document.getElementById('importDialog').style.display='none'; document.body.style.overflow=''; }
  document.getElementById('btnOverwrite').onclick=()=>{ if(!importDialogCtx) return; importDialogCtx.resolve('overwrite'); closeImportDialog(); };
  document.getElementById('btnSkip').onclick=()=>{ if(!importDialogCtx) return; importDialogCtx.resolve('skip'); closeImportDialog(); };
  document.getElementById('btnApplyAll').onclick=()=>{ if(!importDialogCtx) return; importDialogCtx.resolve('applyAllOverwrite'); closeImportDialog(); };
  document.getElementById('importClose').onclick=()=>{ if(importDialogCtx) importDialogCtx.resolve('skip'); closeImportDialog(); };
  function askConflict(message){ return new Promise(resolve=>{ showImportDialog(message,{resolve}); }); }

  /***** Подсказки по именам *****/
  function buildAllNamesIndex(){
    const set=new Set(); db.categories.forEach(c=> (c.items||[]).forEach(it=> set.add((it.name||"").trim().toLowerCase()) )); return set;
  }
  function attachSuggestions(input){
    const wrap=document.createElement('div'); wrap.style.position='relative'; input.parentNode.insertBefore(wrap,input); wrap.appendChild(input);
    const sug=document.createElement('div'); sug.className='suggestions'; sug.style.display='none'; wrap.appendChild(sug);
    input.addEventListener('input',()=>{
      const q=(input.value||"").trim().toLowerCase();
      if(!q){sug.style.display='none';sug.innerHTML='';return;}
      const names=[...buildAllNamesIndex()].filter(n=>n.includes(q)).slice(0,30);
      if(names.length===0){sug.style.display='none';sug.innerHTML='';return;}
      sug.innerHTML=names.map(n=>`<div>${n}</div>`).join(''); sug.style.display='block';
    });
    sug.addEventListener('click',e=>{ if(e.target && e.target.tagName==='DIV'){ input.value=e.target.textContent; sug.style.display='none'; } });
    document.addEventListener('click',ev=>{ if(!wrap.contains(ev.target)) sug.style.display='none'; });
  }

  /***** Мультиселект модал *****/
  const $cascade=document.getElementById('cascadeBox');
  const $msOverlay=document.getElementById('msOverlay');
  const $msTitle=document.getElementById('msTitle');
  const $msSearch=document.getElementById('msSearch');
  const $msGrid=document.getElementById('msGrid');
  const $msApply=document.getElementById('msApply');
  const $msCancel=document.getElementById('msCancel');
  const $msClose=document.getElementById('msClose');
  const $ms