<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>location_selector_v38.7R — стабильная база + undo/redo + collapsible</title>

<!-- Leaflet + плагины -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

<!-- localForage для IndexedDB -->
<script src="https://unpkg.com/localforage@1.10.0/dist/localforage.js"></script>

<style>
:root{--bg:#0b0f16;--panel:#121826;--panel2:#172133;--border:#273248;--text:#d7e2f2;--muted:#9fb0c8;--accent:#4aa8ff;--danger:#ef4444}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Roboto,Arial}
header{display:flex;gap:8px;align-items:center;padding:10px 12px;background:#0e1420;border-bottom:1px solid var(--border)}
button{padding:6px 10px;border-radius:6px;border:1px solid var(--border);background:#1a2234;color:#d7e2f2;cursor:pointer}
button:hover{border-color:var(--accent)}
button.danger{background:#3a0f15;border-color:#7f1d1d;color:#fecaca}
.badge{background:#23314d;border:1px solid #334567;border-radius:8px;padding:3px 8px;font-weight:700}
.tabs{display:flex;gap:8px;padding:8px;border-bottom:1px solid var(--border);background:#121826}
.tab{padding:6px 12px;background:#1a2234;border:1px solid var(--border);border-radius:6px;cursor:pointer}
.tab.active{background:#2160ff;color:#fff}
main{display:grid;grid-template-columns:460px 1fr;height:calc(100vh - 94px)}
.sidebar{padding:10px;border-right:1px solid var(--border);background:#121826;overflow:auto}
.panel{background:var(--panel2);border:1px solid var(--border);border-radius:12px;padding:10px;margin-bottom:10px}
h3{margin:0 0 8px 0}
h4{margin:0 0 8px 0}
input,select,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid #31405a;background:#0f1624;color:#e7f1ff}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.list{display:grid;gap:6px}
.item{border:1px solid var(--border);border-radius:8px;padding:6px 8px;background:#111a2a;margin-bottom:4px}
.item.active{border:1px solid var(--accent);background:#1f2d44}
.item-header{display:flex;justify-content:space-between;align-items:center;cursor:pointer}
.item .left{display:grid;gap:2px}
.item .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:240px}
.item .meta{color:var(--muted);font-size:12px}
.tools{display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin-top:6px}
.sep{height:1px;background:#243048;margin:8px 0}
.help{font-size:12px;color:#9fb0c8}
.note{background:#0e1524;border:1px dashed #32405a;padding:8px;border-radius:8px;color:#9fb0c8}
.note.gray{opacity:.6}
#map{width:100%;height:100%}
.preview-icon{width:20px;height:20px;border-radius:4px;border:1px solid #31405a;background:#0f1624;display:flex;align-items:center;justify-content:center;overflow:hidden}
.preview-icon img{max-width:100%;max-height:100%;display:block}

/* мультиселект */
.multi-select{position:relative;width:100%}
.multi-select-btn{width:100%;padding:6px 8px;background:#1a2234;border:1px solid var(--border);border-radius:6px;cursor:pointer;text-align:left;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.multi-select-menu{position:absolute;top:100%;left:0;right:0;background:var(--panel2);border:1px solid var(--border);border-radius:12px;z-index:2000;max-height:260px;overflow:auto;display:none;text-align:left}
.multi-select.open .multi-select-menu{display:block}
.multi-select-menu label{display:flex;align-items:center;gap:8px;padding:6px 10px;cursor:pointer}
.multi-select-menu label:hover{background:#1f293d}
.multi-select-menu input[type="checkbox"]{
  appearance:none;-webkit-appearance:none;
  width:16px;height:16px;border:2px solid var(--accent);border-radius:4px;
  background:#1a2234;cursor:pointer;position:relative;flex:0 0 16px
}
.multi-select-menu input[type="checkbox"]:checked{background:var(--accent);border-color:var(--accent)}
.multi-select-menu input[type="checkbox"]:checked::after{
  content:"✔";position:absolute;top:-2px;left:2px;font-size:14px;color:#fff
}

/* поиск */
#globalSearch{width:100%;padding:6px 8px;margin-bottom:8px;border-radius:6px;border:1px solid var(--border);background:#0f1624;color:#fff}
.search-results{max-height:200px;overflow:auto;margin-top:6px}
.search-results div{padding:4px 6px;border-bottom:1px solid var(--border);cursor:pointer}
.search-results div:hover{background:#1f293d}

/* поиск по полигонам */
#polySearch{width:100%;padding:6px 8px;margin:8px 0;border-radius:6px;border:1px solid var(--border);background:#0f1624;color:#fff}
</style>
</head>
<body>
<header>
  <span class="badge">dictionary v38.7R</span>
  <button id="btnExport">Экспорт</button>
  <button id="btnImport">Импорт</button>
  <input type="file" id="fileImport" accept=".json,.txt" style="display:none"/>
  <button id="btnReset" class="danger">Сброс</button>
</header>

<div class="tabs">
  <div class="tab active" data-tab="editor">Редактор</div>
  <div class="tab" data-tab="preview">Предпросмотр</div>
</div>

<main>
  <aside class="sidebar" id="editorTab"></aside>
  <aside class="sidebar" id="previewTab" style="display:none">
    <div class="panel">
      <h3>Предпросмотр каскада</h3>
      <input id="globalSearch" placeholder="Поиск по элементам..."/>
      <div id="searchResults" class="search-results"></div>
      <div class="help">До 5 названий видно в кнопке, дальше счётчик. Клики по чекбоксам не закрывают меню.</div>
      <div id="cascadeBox" style="margin-top:8px"></div>

      <div class="sep"></div>
      <h3>Полигоны</h3>
      <input id="polyName" placeholder="Название полигона"/>
      <input type="color" id="polyColor" value="#ff4d4f"/>
      <div class="row">
        <button id="btnPolyNew">Новый</button>
        <button id="btnPolyEdit">Редактировать</button>
        <button id="btnPolyStop">Стоп</button>
        <button id="btnUndo">Undo</button>
        <button id="btnRedo">Redo</button>
      </div>
      <input id="polySearch" placeholder="Поиск по полигонам..."/>
      <div id="polyList" class="list"></div>
    </div>
  </aside>
  <div id="map"></div>
</main>

<!-- Скрипты карт -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

<script>
/***** STORAGE + DB *****/
const KEY="dict_v38_7R";
const lfIcons=localforage.createInstance({name:"dict_icons_v387R"});
const lfGeo=localforage.createInstance({name:"dict_geo_v387R"});

function uid(){return Math.random().toString(36).slice(2,9);}

function normalize(obj){
  if(!obj||typeof obj!=="object")obj={categories:[],polygons:[]};
  if(!Array.isArray(obj.categories)) obj.categories=[];
  if(!Array.isArray(obj.polygons)) obj.polygons=[];
  obj.categories.forEach(c=>{
    if(!("id" in c))c.id=uid();
    if(!("type" in c))c.type="select";
    if(!("items" in c))c.items=[];
    if(!("color" in c))c.color="#3388ff";
    if(!("shape" in c))c.shape="circle";
    if(!("parentCategoryId" in c))c.parentCategoryId=null;
    c.items.forEach(it=>{
      if(!("id" in it))it.id=uid();
      if(!("name" in it))it.name="Без имени";
      if(!("lat" in it))it.lat=null;
      if(!("lng" in it))it.lng=null;
      if(!("parentId" in it))it.parentId=null;
    });
  });
  obj.polygons.forEach(p=>{
    if(!("id" in p))p.id=uid();
    if(!("name" in p))p.name="Полигон";
    if(!("color" in p))p.color="#ff4d4f";
    if(!("visible" in p))p.visible=true;
  });
}
// лёгкий слепок в LS, тяжёлое в IndexedDB
async function save(obj=db){
  normalize(obj);
  const lite={
    categories:obj.categories.map(c=>({
      id:c.id,name:c.name,type:c.type,parentCategoryId:c.parentCategoryId,
      color:c.color,shape:c.shape,iconKey:c.iconKey||null,
      items:(c.items||[]).map(it=>({id:it.id,name:it.name,parentId:it.parentId,lat:it.lat,lng:it.lng,iconKey:it.iconKey||null}))
    })),
    polygons:obj.polygons.map(p=>({id:p.id,name:p.name,color:p.color,visible:p.visible}))
  };
  localStorage.setItem(KEY,JSON.stringify(lite));

  for(const cat of obj.categories){
    if(cat.iconData){
      const key=cat.iconKey||`cat_${cat.id}`;
      await lfIcons.setItem(key,cat.iconData);
      cat.iconKey=key;
    }
    for(const it of (cat.items||[])){
      if(it.iconData){
        const key=it.iconKey||`item_${it.id}`;
        await lfIcons.setItem(key,it.iconData);
        it.iconKey=key;
      }
    }
  }
  for(const p of obj.polygons){
    if(p.geojson) await lfGeo.setItem(p.id,p.geojson);
  }
}

async function loadDB(){
  const raw=localStorage.getItem(KEY);
  let obj={categories:[],polygons:[]};
  if(raw){try{obj=JSON.parse(raw)||{};}catch(e){}}
  normalize(obj);
  for(const cat of obj.categories){
    if(cat.iconKey&&!cat.iconData){
      try{cat.iconData=await lfIcons.getItem(cat.iconKey)||null;}catch(e){}
    }
    for(const it of (cat.items||[])){
      if(it.iconKey&&!it.iconData){
        try{it.iconData=await lfIcons.getItem(it.iconKey)||null;}catch(e){}
      }
    }
  }
  for(const p of obj.polygons){
    if(!p.geojson){
      try{p.geojson=await lfGeo.getItem(p.id)||null;}catch(e){}
    }
  }
  return obj;
}

/***** MAP + MARKERS *****/
let map=L.map('map').setView([41.3111,69.2797],12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

let cluster=L.markerClusterGroup();
map.addLayer(cluster);
function clearMarkers(){cluster.clearLayers();}

function markerIcon(cat,it=null){
  if(it && it.iconData) return L.icon({iconUrl:it.iconData,iconSize:[24,24],iconAnchor:[12,12]});
  if(cat.iconData) return L.icon({iconUrl:cat.iconData,iconSize:[24,24],iconAnchor:[12,12]});
  const color=cat.color||"#3388ff"; const shape=cat.shape||"circle"; let html="";
  if(shape==="circle") html=`<div style="background:${color};width:18px;height:18px;border-radius:50%;border:2px solid #fff"></div>`;
  if(shape==="square") html=`<div style="background:${color};width:18px;height:18px;border:2px solid #fff"></div>`;
  if(shape==="triangle") html=`<div style="width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:18px solid ${color}"></div>`;
  return L.divIcon({className:"custom-icon",html,iconSize:[20,20],iconAnchor:[10,10]});
}
function addMarkerForItem(it,cat){
  if(it.lat==null||it.lng==null) return;
  const m=L.marker([it.lat,it.lng],{icon:markerIcon(cat,it)});
  m.bindPopup(`<b>${it.name}</b><br/><button onclick="removeMarkerById('${it.id}')">🗑 Удалить метку</button>`);
  cluster.addLayer(m);
}
window.removeMarkerById=function(id){
  for(const c of db.categories){
    const it=(c.items||[]).find(x=>x.id===id);
    if(it){it.lat=null;it.lng=null;break;}
  }
  save(); renderAll();
};

/***** POLYGONS CORE *****/
const polyFG=new L.FeatureGroup();
map.addLayer(polyFG);
const polyIndex=new Map();

// история undo/redo
let history=[], historyIndex=-1;
function pushHistory(){
  if(!polyEditingTargetId) return;
  const l=polyIndex.get(polyEditingTargetId);
  if(!l) return;
  const geo=l.toGeoJSON();
  history=history.slice(0,historyIndex+1);
  history.push(geo);
  historyIndex=history.length-1;
}
function applyHistory(i){
  if(i<0||i>=history.length) return;
  const l=polyIndex.get(polyEditingTargetId);
  if(!l) return;
  l.setLatLngs(L.geoJSON(history[i]).getLayers()[0].getLatLngs());
  l.redraw();
}
document.getElementById('btnUndo').onclick=()=>{
  if(historyIndex>0){historyIndex--;applyHistory(historyIndex);}
};
document.getElementById('btnRedo').onclick=()=>{
  if(historyIndex<history.length-1){historyIndex++;applyHistory(historyIndex);}
};

function layerFromGeo(geo,c){
  let l=null;
  L.geoJSON(geo,{style:{color:c||'#ff4d4f',weight:2,fillOpacity:.12}}).eachLayer(x=>l=x);
  return l;
}
function rebuildPolys(){
  polyIndex.clear();
  polyFG.clearLayers();
  for(const p of db.polygons){
    if(!p.geojson) continue;
    const l=layerFromGeo(p.geojson,p.color);
    if(!l) continue;
    polyFG.addLayer(l);
    polyIndex.set(p.id,l);
    if(p.visible===false) map.removeLayer(l);
  }
  updatePolygonVisibility();
}

/***** POLYGON UI + EDIT EVENTS *****/
const $polyList=document.getElementById('polyList');
const $polyName=document.getElementById('polyName');
const $polyColor=document.getElementById('polyColor');
const $polySearch=document.getElementById('polySearch');

let polyEditToolbar=null, polyEditing=false, polyEditingTargetId=null;

document.getElementById('btnPolyNew').onclick=()=>{
  new L.Draw.Polygon(map,{shapeOptions:{color:$polyColor.value||'#ff4d4f',weight:2,fillOpacity:.12}}).enable();
};

document.getElementById('btnPolyEdit').onclick=()=>{
  if(polyEditing) return;
  polyEditingTargetId=null;
  localStorage.removeItem('polyEditingId');
  polyEditToolbar=new L.EditToolbar.Edit(map,{featureGroup:polyFG});
  polyEditToolbar.enable(); polyEditing=true;
};
document.getElementById('btnPolyStop').onclick=()=>{
  if(polyEditing&&polyEditToolbar){polyEditToolbar.disable();polyEditing=false;map.fire(L.Draw.Event.EDITSTOP);}
  polyEditingTargetId=null;
  localStorage.removeItem('polyEditingId');
};

map.on(L.Draw.Event.CREATED,async e=>{
  if(!(e.layer instanceof L.Polygon)) return;
  const layer=e.layer;
  layer.setStyle({color:$polyColor.value||'#ff4d4f',weight:2,fillOpacity:.12});
  polyFG.addLayer(layer);
  const rec={
    id:uid(),
    name:($polyName?.value||`Полигон ${db.polygons.length+1}`).trim(),
    color:$polyColor?.value||'#ff4d4f',
    visible:true,
    geojson:layer.toGeoJSON()
  };
  db.polygons.push(rec);
  polyIndex.set(rec.id,layer);
  setEditingTarget(rec.id);
  pushHistory();
  await save(db);
  renderPolyList(); updatePolygonVisibility();
});

map.on(L.Draw.Event.EDITSTOP,async ()=>{
  for(const p of db.polygons){
    const l=polyIndex.get(p.id);
    if(l) p.geojson=l.toGeoJSON();
  }
  pushHistory();
  await save(db);
  renderPolyList(); updatePolygonVisibility();
});

function setEditingTarget(id){
  polyEditingTargetId=id||null;
  if(id) localStorage.setItem('polyEditingId',id); else localStorage.removeItem('polyEditingId');
  history=[];historyIndex=-1;
  if(id) pushHistory();
  renderPolyList();
  updatePolygonVisibility();
}
/***** COLLAPSE STATE *****/
function loadJsonLS(key, def){ try{ return JSON.parse(localStorage.getItem(key)||def);}catch(_){ return JSON.parse(def);} }
function saveJsonLS(key, val){ localStorage.setItem(key, JSON.stringify(val)); }

let collapsedPolys = loadJsonLS('collapsed_polys_v387R', '{}');
let collapsedCats  = loadJsonLS('collapsed_cats_v387R',  '{}');

/***** POLYGON LIST (collapsible + keep scroll) *****/
function renderPolyList(){
  if(!$polyList) return;
  const q=($polySearch?.value||"").trim().toLowerCase();
  const prevScroll=$polyList.scrollTop;

  $polyList.innerHTML='';
  db.polygons
    .filter(p=>!q || (p.name||'').toLowerCase().includes(q))
    .forEach((p,idx)=>{
      const item=document.createElement('div'); item.className='item'; item.dataset.id=p.id;
      if(p.id===polyEditingTargetId) item.classList.add('active');

      // header
      const header=document.createElement('div'); header.className='item-header';
      const leftHead=document.createElement('div'); leftHead.className='left';
      const nameDiv=document.createElement('div'); nameDiv.className='name'; nameDiv.textContent=p.name||`Полигон ${idx+1}`;
      const metaDiv=document.createElement('div'); metaDiv.className='meta'; metaDiv.textContent=`id: ${p.id}`;
      leftHead.append(nameDiv, metaDiv);

      const foldBtn=document.createElement('button'); 
      const isCollapsed = !!collapsedPolys[p.id];
      foldBtn.textContent = isCollapsed ? '▶' : '▼';
      foldBtn.title='Свернуть/развернуть';
      foldBtn.onclick=()=>{
        collapsedPolys[p.id] = !collapsedPolys[p.id];
        saveJsonLS('collapsed_polys_v387R', collapsedPolys);
        renderPolyList();
      };

      header.append(leftHead, foldBtn);
      item.appendChild(header);

      // body (tools)
      const body=document.createElement('div'); body.className='tools';
      if(isCollapsed) body.style.display='none';

      // цвет
      const color=document.createElement('input'); color.type='color'; color.value=p.color||'#ff4d4f';
      color.onchange=async()=>{p.color=color.value; const l=polyIndex.get(p.id); if(l&&l.setStyle) l.setStyle({color:p.color}); await save(db);};

      // показать/скрыть
      const toggle=document.createElement('button'); toggle.textContent=p.visible!==false?'Скрыть':'Показать';
      toggle.onclick=async()=>{p.visible=!(p.visible!==false); const l=polyIndex.get(p.id); if(l){ if(p.visible) l.addTo(map); else map.removeLayer(l);} await save(db); renderPolyList(); updatePolygonVisibility();};

      // фокус
      const focus=document.createElement('button'); focus.textContent='Фокус';
      focus.onclick=()=>{const l=polyIndex.get(p.id); if(l){ if(p.visible===false){p.visible=true; l.addTo(map);} map.fitBounds(l.getBounds()); }};

      // редактировать
      const editBtn=document.createElement('button'); editBtn.textContent='Редактировать';
      editBtn.onclick=()=>{
        const l=polyIndex.get(p.id);
        if(!l) return;
        l.addTo(map);
        if(polyEditing&&polyEditToolbar){ polyEditToolbar.disable(); }
        polyEditToolbar=new L.EditToolbar.Edit(map,{featureGroup:polyFG});
        polyEditToolbar.enable(); polyEditing=true;
        polyFG.eachLayer(x=>{
          if(x===l){ if(x.editing && !x.editing._enabled) x.editing.enable(); }
          else{ if(x.editing && x.editing._enabled) x.editing.disable(); }
        });
        setEditingTarget(p.id);
        pushHistory(); // стартовое состояние в историю
        map.fitBounds(l.getBounds());
      };

      // удалить
      const del=document.createElement('button'); del.textContent='❌'; del.className='danger';
      del.onclick=async()=>{ if(!confirm('Удалить полигон?')) return;
        const l=polyIndex.get(p.id); if(l) polyFG.removeLayer(l);
        polyIndex.delete(p.id);
        db.polygons=db.polygons.filter(x=>x.id!==p.id);
        try{ await lfGeo.removeItem(p.id); }catch(_){}
        await save(db);
        delete collapsedPolys[p.id]; saveJsonLS('collapsed_polys_v387R', collapsedPolys);
        if(polyEditingTargetId===p.id){ setEditingTarget(null); }
        renderPolyList(); updatePolygonVisibility();
      };

      body.append(color, toggle, focus, editBtn, del);
      item.appendChild(body);

      $polyList.appendChild(item);
    });

  // восстановить скролл (чтобы не «прыгало» на undo/redo и др. операциях)
  requestAnimationFrame(()=>{ $polyList.scrollTop = prevScroll; });
}

$polySearch.oninput=renderPolyList;

/***** SELECTION & VISIBILITY *****/
let selected={};
function saveSelected(){localStorage.setItem('selected_v387R',JSON.stringify(selected));}
function loadSelected(){try{selected=JSON.parse(localStorage.getItem('selected_v387R')||'{}');}catch(_){selected={};}}

function updatePolygonVisibility(){
  // простая логика: если редактируем — обязательно показывать его;
  // остальные — по флагу visible.
  for(const p of db.polygons){
    const l=polyIndex.get(p.id); if(!l) continue;
    const force = (polyEditingTargetId && p.id===polyEditingTargetId);
    if(force || p.visible!==false){ l.addTo(map); } else { map.removeLayer(l); }
  }
}

/***** EDITOR (категории + элементы, collapsible) *****/
const $editor=document.getElementById('editorTab');

function renderEditor(){
  const prevScroll = $editor.scrollTop;
  $editor.innerHTML="";

  // новая категория
  const create=document.createElement('div'); create.className='panel';
  create.innerHTML=`
    <h3>Новая категория</h3>
    <div class="row">
      <input id="newCatName" placeholder="Название"/>
      <select id="newCatType"><option value="select">Select</option><option value="checkbox">Checkbox</option></select>
      <input type="color" id="newCatColor" value="#3388ff"/>
      <select id="newCatShape"><option value="circle">Круг</option><option value="square">Квадрат</option><option value="triangle">Треугольник</option></select>
      <button id="btnAddCat">+ Добавить</button>
    </div>`;
  $editor.appendChild(create);

  create.querySelector('#btnAddCat').onclick=async()=>{
    const name=document.getElementById('newCatName').value.trim(); if(!name) return;
    const type=document.getElementById('newCatType').value;
    const color=document.getElementById('newCatColor').value;
    const shape=document.getElementById('newCatShape').value;
    db.categories.push({id:uid(),name,type,color,shape,items:[]});
    await save(); renderAll();
  };

  // список категорий
  db.categories.forEach((cat,ci)=>{
    const sec=document.createElement('div'); sec.className='panel';

    // заголовок с кнопкой сворачивания
    const head=document.createElement('div'); head.className='item-header';
    const h=document.createElement('h3'); h.textContent=cat.name+` (${cat.type})`;
    const fold=document.createElement('button');
    const isCollapsed = !!collapsedCats[cat.id];
    fold.textContent = isCollapsed ? '▶' : '▼';
    fold.onclick=()=>{ collapsedCats[cat.id]=!collapsedCats[cat.id]; saveJsonLS('collapsed_cats_v387R', collapsedCats); renderEditor(); };
    head.append(h, fold);
    sec.appendChild(head);

    // тело категории
    const body=document.createElement('div');
    if(isCollapsed) body.style.display='none';

    // элементы
    const list=document.createElement('div'); list.className='list';
    (cat.items||[]).forEach((it,ii)=>{
      const line=document.createElement('div'); line.className='item';
      const innerHead=document.createElement('div'); innerHead.className='item-header';

      const left=document.createElement('div'); left.className='left';
      const nm=document.createElement('div'); nm.className='name'; nm.textContent=it.name;
      const meta=document.createElement('div'); meta.className='meta'; meta.textContent=`lat:${it.lat??'—'} lng:${it.lng??'—'}`;
      left.append(nm,meta);

      const tools=document.createElement('div'); tools.className='tools';

      const edit=document.createElement('button'); edit.textContent='✎';
      edit.onclick=()=>{const nn=prompt('Новое имя',it.name); if(nn!=null){it.name=(nn.trim()||it.name); save(); renderEditor();}};

      const place=document.createElement('button'); place.textContent='📍';
      place.onclick=()=>{
        alert('Кликни по карте для: '+it.name);
        map.once('click', e=>{
          it.lat=e.latlng.lat; it.lng=e.latlng.lng; save();
          meta.textContent=`lat:${it.lat.toFixed(5)} lng:${it.lng.toFixed(5)}`;
          addMarkerForItem(it,cat);
          map.setView([it.lat,it.lng],14);
        });
      };

      const clearBtn=document.createElement('button'); clearBtn.textContent='🗑 метка';
      clearBtn.onclick=()=>{it.lat=null; it.lng=null; save(); renderEditor();};

      const del=document.createElement('button'); del.textContent='❌'; del.className='danger';
      del.onclick=()=>{if(confirm('Удалить "'+it.name+'"?')){cat.items.splice(ii,1); save(); renderEditor();}};

      tools.append(edit,place,clearBtn,del);
      innerHead.append(left,document.createElement('span'));
      line.append(innerHead,tools);
      list.appendChild(line);
    });
    body.appendChild(list);

    // добавить элемент
    const addRow=document.createElement('div'); addRow.className='row';
    const inp=document.createElement('input'); inp.placeholder='Новый элемент';
    const addBtn=document.createElement('button'); addBtn.textContent='+ Добавить';
    addBtn.onclick=()=>{ const nm=inp.value.trim()||'Новый'; cat.items.push({id:uid(),name:nm,lat:null,lng:null,parentId:null}); inp.value=''; save(); renderEditor(); };
    addRow.append(inp,addBtn);
    body.appendChild(addRow);

    sec.appendChild(body);
    $editor.appendChild(sec);
  });

  // вернуть скролл
  requestAnimationFrame(()=>{ $editor.scrollTop = prevScroll; });
}

/***** PREVIEW (простой селект + маркеры) *****/
const $cascade=document.getElementById('cascadeBox');
const $preview=document.getElementById('previewTab');

function renderPreview(){
  const prevScroll = $preview.scrollTop;
  $cascade.innerHTML="";
  clearMarkers();

  db.categories.forEach(cat=>{
    const box=document.createElement('div'); box.className='panel';
    const h=document.createElement('h4'); h.textContent=cat.name; box.appendChild(h);

    const sel=document.createElement('select'); sel.style.width='100%';
    sel.innerHTML=`<option value="">— выберите —</option>`+(cat.items||[]).map(it=>`<option value="${it.id}">${it.name}</option>`).join('');
    if(selected[cat.id]) sel.value=selected[cat.id];
    sel.onchange=()=>{ selected[cat.id]=sel.value||null; saveSelected(); renderPreview(); };
    box.appendChild(sel);

    $cascade.appendChild(box);
  });

  // Показать маркеры для выбранных
  db.categories.forEach(cat=>{
    const id=selected[cat.id];
    if(!id) return;
    const it=(cat.items||[]).find(x=>x.id===id);
    if(it && it.lat!=null && it.lng!=null) addMarkerForItem(it,cat);
  });

  requestAnimationFrame(()=>{ $preview.scrollTop = prevScroll; });
}

/***** SEARCH (элементы) *****/
const $search=document.getElementById('globalSearch');
const $results=document.getElementById('searchResults');
$search.oninput=()=>{
  const q=$search.value.trim().toLowerCase();
  $results.innerHTML="";
  if(!q) return;

  db.categories.forEach(cat=>{
    (cat.items||[]).forEach(it=>{
      if((it.name||'').toLowerCase().includes(q)){
        const row=document.createElement('div');
        row.textContent=`${it.name} (${cat.name})`;
        row.onclick=()=>{
          selected[cat.id]=it.id; saveSelected(); renderPreview();
          if(it.lat!=null && it.lng!=null) map.setView([it.lat,it.lng],14);
          $search.value=""; $results.innerHTML="";
        };
        $results.appendChild(row);
      }
    });
  });
};

/***** EXPORT/IMPORT/RESET *****/
document.getElementById('btnExport').onclick=async ()=>{
  const full=JSON.parse(JSON.stringify(db));
  for(const cat of full.categories){
    if(cat.iconKey && !cat.iconData){ try{ cat.iconData=await lfIcons.getItem(cat.iconKey)||null; }catch(_){ } }
    for(const it of (cat.items||[])){
      if(it.iconKey && !it.iconData){ try{ it.iconData=await lfIcons.getItem(it.iconKey)||null; }catch(_){ } }
    }
  }
  for(const p of full.polygons){
    if(!p.geojson){ try{ p.geojson=await lfGeo.getItem(p.id)||null; }catch(_){ } }
  }
  const blob=new Blob([JSON.stringify(full,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='dict_full_v38_7R.json'; a.click();
};

document.getElementById('btnImport').onclick=()=>document.getElementById('fileImport').click();
document.getElementById('fileImport').onchange=e=>{
  const f=e.target.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=async ()=>{
    try{
      let obj=JSON.parse(r.result);
      if(obj && obj.db) obj=obj.db;
      if(!Array.isArray(obj.categories)) throw new Error('Нет categories');
      if(!Array.isArray(obj.polygons))   obj.polygons=[];

      // Иконки → IndexedDB
      for(const cat of obj.categories){
        if(!cat.id) cat.id=uid();
        if(cat.iconData){
          const key=cat.iconKey||`cat_${cat.id}`;
          await lfIcons.setItem(key,cat.iconData);
          cat.iconKey=key;
        }
        for(const it of (cat.items||[])){
          if(!it.id) it.id=uid();
          if(it.iconData){
            const key=it.iconKey||`item_${it.id}`;
            await lfIcons.setItem(key,it.iconData);
            it.iconKey=key;
          }
        }
      }
      // Полигоны → IndexedDB
      for(const p of obj.polygons){
        if(!p.id) p.id=uid();
        if(p.geojson){ await lfGeo.setItem(p.id,p.geojson); }
      }

      // сохранить лайт и перезагрузить
      localStorage.setItem(KEY, JSON.stringify({
        categories:obj.categories.map(c=>({
          id:c.id,name:c.name,type:c.type,parentCategoryId:c.parentCategoryId,
          color:c.color,shape:c.shape,iconKey:c.iconKey||null,
          items:(c.items||[]).map(it=>({id:it.id,name:it.name,parentId:it.parentId,lat:it.lat,lng:it.lng,iconKey:it.iconKey||null}))
        })),
        polygons:obj.polygons.map(p=>({id:p.id,name:p.name,color:p.color,visible:p.visible}))
      }));
      db = await loadDB();

      renderAll();
      resumeEditingIfNeeded();
      alert('Импортировано');
    }catch(err){ alert('Ошибка импорта: '+err.message); }
  };
  r.readAsText(f);
};

document.getElementById('btnReset').onclick=()=>{
  if(confirm('Очистить всё?')){
    localStorage.removeItem(KEY);
    localStorage.removeItem('selected_v387R');
    localStorage.removeItem('polyEditingId');
    localStorage.removeItem('collapsed_polys_v387R');
    localStorage.removeItem('collapsed_cats_v387R');
    try{ lfIcons.clear(); }catch(_){}
    try{ lfGeo.clear(); }catch(_){}
    location.reload();
  }
};

/***** TABS *****/
document.querySelectorAll('.tab').forEach(tab=>{
  tab.onclick=()=>{
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    tab.classList.add('active');
    const which=tab.dataset.tab;
    document.getElementById('editorTab').style.display=which==='editor'?'block':'none';
    document.getElementById('previewTab').style.display=which==='preview'?'block':'none';
  };
});

/***** MAIN RENDER *****/
function renderAll(){
  rebuildPolys();
  renderEditor();
  renderPreview();
  renderPolyList();

  // маркеры для всех имеющихся точек
  clearMarkers();
  db.categories.forEach(cat=>{
    (cat.items||[]).forEach(it=>{
      if(it.lat!=null && it.lng!=null) addMarkerForItem(it,cat);
    });
  });
}

/***** RESUME EDIT MODE *****/
function resumeEditingIfNeeded(){
  const id=localStorage.getItem('polyEditingId');
  if(!id) return;
  const layer=polyIndex.get(id);
  if(!layer) return;

  if(polyEditing&&polyEditToolbar){ polyEditToolbar.disable(); }
  polyEditToolbar=new L.EditToolbar.Edit(map,{featureGroup:polyFG});
  polyEditToolbar.enable(); polyEditing=true;

  polyFG.eachLayer(x=>{
    if(x===layer){ if(x.editing && !x.editing._enabled) x.editing.enable(); }
    else{ if(x.editing && x.editing._enabled) x.editing.disable(); }
  });

  setEditingTarget(id);
  layer.addTo(map);
  map.fitBounds(layer.getBounds());
  pushHistory(); // базовое состояние в undo-стек
}

/***** START *****/
let db=null;
(async()=>{
  db = await loadDB();
  loadSelected();
  renderAll();
  resumeEditingIfNeeded();
})();
</script>
</body>
</html>
